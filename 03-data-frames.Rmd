---
layout: topic
title: The `data.frame` class
author: Data Carpentry contributors
minutes: 30
---

```{r, echo=FALSE, purl=FALSE, message = FALSE}
source("setup.R")
surveys <- read.csv("data/portal_data_joined.csv")
```

```{r, echo=FALSE, purl=TRUE}
## The data.frame class
```

------------

> ## Learning Objectives
>
> * understand the concept of a `data.frame`
> * use sequences
> * know how to access any element of a `data.frame`

------------

## What are data frames?

Data frames are the main data structure for working with tabular data, doing
statistics, and making graphs.

A data frame is a collection of vectors of identical lengths. Each vector
represents a column, and each vector can be of a different data type (e.g.,
characters, integers, factors). The `str()` function is useful to inspect the
data types of the columns.

A data frame can be created by hand, but most commonly they are generated by the
functions `read.csv()` or `read.table()`; in other words, when importing data.

You can also create a data frame manually with the function `data.frame()`.

```{r, results='show', purl=TRUE}
## Compare the output of these examples, and compare the difference between when
## the data are being read as `character`, and when they are being read as
## `factor`.
pet_data <- data.frame(animal=c("dog", "cat", "sea cucumber", "sea urchin"),
                       weight=c(45, 8, 1.1, 0.8),
                       feel=c("furry", "furry", "squishy", "spiny"))
str(pet_data)
```

By default, when building or importing a data frame, the columns that contain
characters (i.e., text) are converted into the `factor` data type. This is a special
data type in R that can be useful for statistics, but can also cause code to behave
in unexpected ways. If you want to keep this data as actual text, you can do this 
using the optional `stringsAsFactors` argument in `read.csv()` and `read.table()`.

```{r, results='show', purl=TRUE}
pet_data <- data.frame(animal=c("dog", "cat", "sea cucumber", "sea urchin"),
                       weight=c(45, 8, 1.1, 0.8),
                       feel=c("furry", "furry", "squishy", "spiny"),
                       stringsAsFactors=FALSE)
str(pet_data)
```

We can also use this argument when loading a data frame with `read.csv`.

## Inspecting `data.frame` Objects

We already saw how the functions `head()` and `str()` can be useful to check the
content and the structure of a `data.frame`.

We can also look at things like how many rows and columns at data frame has:

```{r, results='show', purl=TRUE}
nrow(pet_data)
ncol(pet_data)
```

The names of the columns:

```{r, results='show', purl=TRUE}
colnames(pet_data)
```

And get summary statistics for each column:

```{r, results='show', purl=TRUE}
summary(pet_data)
```

### Challenge

1. For the Portal data find the number of rows, number of columns, and get
   summary statistics for each column in the dataset.

```{r, echo=FALSE, purl=TRUE}
### For the Portal data find the number of rows, number of columns, and get
### summary statistics for each column in the dataset.
```

<!---
```{r, purl=FALSE}
## Answer
nrow(surveys)
ncol(surveys)
summary(surveys)
```
--->


## Indexing, Sequences, and Subsetting

```{r, echo=FALSE, purl=TRUE}

## Indexing, Sequences, and Subsetting

```

Our survey data frame has rows and columns (it has 2 dimensions), so if we want to
extract some specific data from it, we need to specify the "coordinates" we want
from it. Row numbers come first, followed by column numbers.

```{r, purl=FALSE}
surveys[1]      # first column in the data frame
surveys[1, 1]   # first element in the first column of the data frame
surveys[1, 6]   # first element in the 6th column
surveys[1:3, 7] # first three elements in the 7th column
surveys[3, ]    # the 3rd element for all columns
surveys[, 8]    # the entire 8th column
head_surveys <- surveys[1:6, ] # surveys[1:6, ] is equivalent to head(surveys)
```

As well as using numeric values to subset a `data.frame` columns
can be called by name, using one the three following notations:

```{r, eval = FALSE, purl=FALSE}
surveys["species_id"]
surveys$species_id
```

The first approaches produces a data frame with one column and the second produces
a vector.

### Challenge

1. The function `nrow()` on a `data.frame` returns the number of rows. Use it,
   in conjuction with `seq()` to create a new `data.frame` called
   `surveys_by_10` that includes every 10th row of the survey data frame
   starting at row 10 (10, 20, 30, ...)

```{r, echo=FALSE, purl=TRUE}
### The function `nrow()` on a `data.frame` returns the number of
### rows. Use it, in conjuction with `seq()` to create a new
### `data.frame` called `surveys_by_10` that includes every 10th row
### of the survey data frame starting at row 10 (10, 20, 30, ...)
```

<!---
```{r, purl=FALSE}
## Answer
surveys_by_10 <- surveys[seq(10, nrow(surveys), by=10), ]
```
--->

### Conditional subsetting

Besides using the index position of an element in a vector to extract its value
as we saw earlier, we can also use logical vectors:

```{r, purl=FALSE}
animals <- c("mouse", "rat", "dog", "cat")
animals[c(TRUE, FALSE, TRUE, TRUE)]
```

But typically, those logical vectors are not typed by hand but the result of a
logical test:

```{r, purl=FALSE}
animals != "rat"
animals[animals != "rat"]
animals[animals == "cat"]
```

If you can combine multiple tests using `&` (both conditions are true, AND) or `|`
(at least one of the conditions if true, OR):

```{r, purl=FALSE}
animals[animals == "cat" & animals == "rat"] # returns nothing
animals[animals == "cat" | animals == "rat"] # returns both rat and cat
```

If you are trying to combine many conditions, it can become tedious to type. The
function `%in%` allows you to test if a value if found in a vector:

```{r, purl=FALSE}
animals %in% c("rat", "cat", "dog", "duck")
animals[animals %in% c("rat", "cat", "dog", "duck")]
```

In addition to testing equalities, you can also test whether the elements of
your vector are less than or greater than a given value:

```{r, purl=FALSE}
dates <- c(1960, 1963, 1974, 2015, 2016)
dates >= 1974
dates[dates >= 1974]
dates[dates > 1970 & dates <= 2015]
dates[dates < 1975 | dates > 2016]
```

> ### Challenge {.challenge}
>
> * Can you figure out why `"four" > "five"` returns `TRUE`?

```{r, purl=TRUE}
# * Can you figure out why `"four" > "five"` returns `TRUE`?
```

<!--
```{r, purl=FALSE}
## Answers
## * When using ">" or "<" on strings, R compares their alphabetical order. Here
##   "four" comes after "five", and therefore is "greater than" it.
```
-->
